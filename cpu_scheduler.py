# -*- coding: utf-8 -*-
"""CPU scheduler.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PVdPB2VYO8tdq9C2zeTKgOFak1CtmEQF
"""

import math as m
import operator
from collections import OrderedDict
 
 
 
class Process():
 
  def __init__(self,id,burst_time,arrival_time,priority):
    self.id=id
    self.burst_time=burst_time
    self.arrival_time=arrival_time
    self.remaining_time=burst_time
    self.waiting_time=0
    self.priority=priority
 
class CPU_Scheduler:
 
  def __init__(self,t0,cpu_burst,arrival_time,process_priority):
 
    self.cpu_burst=cpu_burst
    self.arrival_time=arrival_time
    self.process_priority=process_priority
    self.t0=t0
    self.alpha=.5
    self.predicted_burst=self.predict_Burst()
    self.process = self.update_process()
    
    print("Predicted Burst: ",self.predicted_burst)
 
    print('\n')
    self.SJF()
    self.SRTF()
    self.PPS()
    self.RR()
 
 
  def predict_Burst(self):
    
    t0=self.t0
    a=self.alpha
    burst=self.cpu_burst
 
    t=[]
 
    for i in range(len(burst)):
 
      if i==0:
        t.append(m.ceil(a*burst[i]+t0*a))
 
      else:
        t.append(m.ceil(a*burst[i]+t[i-1]*a))
    
    predicted_burst=t
 
    return predicted_burst  
 
  def update_process(self):
 
    process=[]
    for _ in range(len(cpu_burst)):
      process.append(Process(_+1,self.predicted_burst[_],self.arrival_time[_],self.process_priority[_]))
    return process
  def update_waiting_time(self,dict):
      for key in dict:
        for _ in range(len(self.process)):
          if self.process[_].id ==key:
            self.process[_].waiting_time=dict[key]
  def SJF(self):
 
    SJF_process=self.process
    SJF_process = sorted(SJF_process, key=operator.attrgetter("burst_time"))
    sequence=[SJF_process[_].id for _ in range(len(SJF_process))]
    intervals=[]
    intervals.append(0)
    cpu_catcher={}
 
    for _ in range(len(SJF_process)):
     intervals.append(SJF_process[_].burst_time+intervals[_])
     cpu_catcher[SJF_process[_].id]=intervals[_]
   
 
    self.update_waiting_time(cpu_catcher)
 
 
    waiting_time=[SJF_process[_].waiting_time for _ in range(len(SJF_process))]
 
    
          
 
    
    print("a. SJF [All processes arrive at 0]:")  
    print('-Sequence: ',sequence)
    print('-Intervals: ',intervals)
    print('-Average Waiting Time:',sum(waiting_time)/len(self.process)," ms ")
    print('\n')
  
  def SRTF(self): 
 
   
 
    process=[]
    predicted_burst=self.predicted_burst
   
    arrival_time=[self.process[_].arrival_time for _ in range(len(self.process))]
    priority=[self.process[_].priority for _ in range(len(self.process))]
 
    sequence=[]
    mem={}
    interval=[]
    cpu_catcher={1:0,2:0,3:0,4:0,5:0}
    interval.append(0)
    i=0
    for _ in range(len(predicted_burst)):
      process.append(Process(_+1,predicted_burst[_],arrival_time[_],priority[_]))
    process=sorted(process, key=operator.attrgetter("arrival_time")) 
    ariv=[process[p].arrival_time for p in range(len(process))]
    for p in range(len(process)-1):
 
 
      process_time=process[p+1].arrival_time-process[p].arrival_time
      rem=process[p].remaining_time-process_time
      if (rem>process[p+1].remaining_time):
        process[p].remaining_time=rem
  
        sequence.append(process[p].id)
      else:
        process_time=process[p].remaining_time
        process[p].remaining_time=0
        sequence.append(process[p].id)
       
      interval.append(interval[i]+process_time)
      i+=1
 
    
      cpu_catcher[process[p].id]=interval[len(interval)-1]
   
 
 
   
 
 
      if (interval[len(interval)-1])>max(ariv):
        cpu_catcher[process[p].id]=interval[len(interval)-1]
 
        
        break
 
 
    
    process = sorted(process, key=operator.attrgetter("remaining_time"))
    for _ in range(len(process)):
      if (process[_].remaining_time!=0):
        interval.append(process[_].remaining_time+interval[len(interval)-1])
        sequence.append(process[_].id)
     
        if cpu_catcher[process[_].id]!=0:
          cpu_catcher[process[_].id]=interval[len(interval)-2]-cpu_catcher[process[_].id]
       
        else:
          cpu_catcher[process[_].id]=interval[len(interval)-2]-process[_].arrival_time
     
 
      else:
        cpu_catcher[process[_].id]=interval[len(interval)-2]-process[_].arrival_time
 
 
 
 
 
    s_w=0
    for _ in cpu_catcher:
      s_w+=cpu_catcher[_]
    avg_w=s_w/5
 
 
    print("b. SRTF")    
    print('-Sequence: ',sequence)
    print('-Intervals: ',interval)
    print('-Average Waiting Time:',avg_w,' ms')
    print('\n')
 
 
      
 
  def PPS(self):
    process=[]
    predicted_burst=self.predicted_burst
   
    arrival_time=[self.process[_].arrival_time for _ in range(len(self.process))]
    priority=[self.process[_].priority for _ in range(len(self.process))]
 
    sequence=[]
    interval=[]
 
    cpu_catcher={1:0,2:0,3:0,4:0,5:0}
    interval.append(0)
    i=0
    for _ in range(len(predicted_burst)):
      process.append(Process(_+1,predicted_burst[_],arrival_time[_],priority[_]))
    process=sorted(process, key=operator.attrgetter("arrival_time"))
 
    ariv=[process[p].arrival_time for p in range(len(process))]   
 
 
    
 
 
    for p in range(len(process)-1):
 
      process_time=process[p+1].arrival_time-process[p].arrival_time
      rem=process[p].remaining_time-process_time
      if (process[p].priority>process[p+1].priority):
        process[p].remaining_time=rem
    
        sequence.append(process[p].id)
 
  
      else:
        process_time=process[p].remaining_time
        process[p].remaining_time=0
       
        sequence.append(process[p].id)
  
      interval.append(interval[i]+process_time)
      i+=1
      if (process[p].remaining_time ==0):
        cpu_catcher[process[p].id]=0
      else:
        cpu_catcher[process[p].id]=interval[len(interval)-1]
 
      if (interval[len(interval)-1])>max(ariv):
        cpu_catcher[process[p].id]=interval[len(interval)-1]
 
        break
 
    process = sorted(process, key=operator.attrgetter("priority"))
    for _ in range(len(process)):
      if (process[_].remaining_time !=0):
        interval.append(process[_].remaining_time+interval[len(interval)-1])
        if (cpu_catcher[process[_].id]!=0):
         
            cpu_catcher[process[_].id]=interval[len(interval)-2]-cpu_catcher[process[_].id]-process[_].arrival_time
       
        else:
          cpu_catcher[process[_].id]=interval[len(interval)-2]-process[_].arrival_time
  
   
        sequence.append(process[_].id)
      else:
        cpu_catcher[process[_].id]=interval[len(interval)-2]-process[_].arrival_time
       
      
 
 
 
 
 
 
    w=0
    for _ in cpu_catcher:
      w+=cpu_catcher[_]
    avg_w=w/5
 
 
    print("c. PPS: ")    
    print('-Sequence: ',sequence)
    print('-Intervals: ',interval)
    print('-Average Waiting Time:',avg_w," ms ")
    print('\n')
 
  
 
 
  
 
  def RR(self):
    q=m.ceil(self.cpu_burst[0]*.5+self.predicted_burst[0]*.5)
    print(q)
 
    process=[]
    predicted_burst=self.predicted_burst
   
    arrival_time=[self.process[_].arrival_time for _ in range(len(self.process))]
    priority=[self.process[_].priority for _ in range(len(self.process))]
 
    sequence=[]
    interval=[]
    cpu_catcher={1:0,2:0,3:0,4:0,5:0}
    interval.append(0)
    i=0
    for _ in range(len(predicted_burst)):
      process.append(Process(_+1,predicted_burst[_],arrival_time[_],priority[_]))
    process=sorted(process, key=operator.attrgetter("arrival_time"))
 
    tot_time=sum(predicted_burst)
    round=m.ceil(tot_time/q)
 
 
 
    for i in range(0,round):
      for p in range(len(process)):
        if (process[p].remaining_time>=q):
          process[p].remaining_time=process[p].remaining_time-q
          sequence.append(process[p].id)
          interval.append(interval[len(interval)-1]+q)
         
          i+=1
          cpu_catcher[process[p].id]=interval[len(interval)-1]
      
        elif (process[p].remaining_time<q and process[p].remaining_time!=0 ):
          sequence.append(process[p].id)
       
          interval.append(interval[len(interval)-1]+process[p].remaining_time)
          i+=1
          process[p].remaining_time=0
          if (cpu_catcher[process[p].id]!=0):
         
            cpu_catcher[process[p].id]=interval[len(interval)-2]-cpu_catcher[process[p].id]
       
          else:
            cpu_catcher[process[p].id]=interval[len(interval)-2]
            
  
 
 
          
    w=0
    for _ in cpu_catcher:
      w+=cpu_catcher[_]
    avg_w=w/5     
    
    print("d. RR [All processes arrive at 0]: ") 
    print("Quantam (Q): ",q)   
    print('-Sequence: ',sequence)
    print('-Intervals: ',interval)
    print('-Average Waiting Time:',avg_w, " ms")
 
    
t0=int(input('ID: '))
cpu_burst=[int(_) for _ in input("Given CPU burst: ").split()]
arrival_time=[int(_) for _ in input("Arrival times: ").split()]
 
if (len(arrival_time) != len(cpu_burst)  ):
  raise ValueError(("Please provide all arrival times"))
  
process_priority=[int(_) for _ in input("Process priority: ").split()]
 
if (len(process_priority) != len(arrival_time)):
  raise ValueError(("Please provide all priority list")) 
 
 
 
 
 
 
print('\n')
  
 
cpu=CPU_Scheduler(t0,cpu_burst,arrival_time,process_priority)
r=cpu.predict_Burst()

